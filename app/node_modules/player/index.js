const queue = require('queue')

function Player (x, y, world) {
	this.offsetY = -22
	this.world = world
	this.queue = queue()
	this.queue.concurrency = 1

	this.sprite = Resources.getSprite('player.png')
	this.sprite.texture.frame = new PIXI.Rectangle(0, 0, this.sprite.width / 4, this.sprite.height / 4)
	this.sprite.position.x = x * this.world.tileSize
	this.sprite.position.y = y * this.world.tileSize + this.offsetY
	this.dx = x
	this.dy = y

	this.moving = false
	this.speed = 2 / this.world.tileSize
	this.direction = 'down'
	this.directionIndex = 0
}

Player.prototype.getPosition = function () {
	let x = this.sprite.position.x / this.world.tileSize
	let y = (this.sprite.position.y - this.offsetY) / this.world.tileSize
	return {x, y}
}

Player.prototype.setPosition = function (x, y) {
	this.sprite.position.x = x * this.world.tileSize
	this.sprite.position.y = y * this.world.tileSize + this.offsetY
	this.dx = x
	this.dy = y
}

Player.prototype.increasePosition = function (dx, dy) {
	this.sprite.position.x += dx * this.world.tileSize
	this.sprite.position.y += dy * this.world.tileSize
}

Player.prototype.getFacingPosition = function () {
	let x = this.getPosition().x
	let y = this.getPosition().y

	if (this.direction === 'down')	y ++
	if (this.direction === 'left')	x --
	if (this.direction === 'right') x ++
	if (this.direction === 'up')	y --

	return {x, y}
}

Player.prototype.getFacingTile = function () {
	return this.world.getTile(this.getFacingPosition().x, this.getFacingPosition().y)
}

Player.prototype.getDirection = function (dx, dy) {
	if (dx !== undefined && dy !== undefined) {
		if (dy > 0) return 'down'
		if (dx < 0) return 'left'
		if (dx > 0) return 'right'
		if (dy < 0) return 'up'
	} else {
		return this.direction
	}
}


Player.prototype.setDirection = function (direction, done) {
	this.direction = direction
	if (this.direction === 'down')	this.directionIndex = 0
	if (this.direction === 'left')	this.directionIndex = 1
	if (this.direction === 'right') this.directionIndex = 2
	if (this.direction === 'up')		this.directionIndex = 3
	this.sprite.texture.frame = new PIXI.Rectangle(0, this.directionIndex * this.sprite.height, this.sprite.width, this.sprite.height)
	if (done) done()
}

Player.prototype.update = function (time) {
	if (this.moving) {
		if (this.getPosition().y < this.dy) {
			this.setDirection('down')
			this.increasePosition(0, this.speed)
		}
		if (this.getPosition().x > this.dx) {
			this.setDirection('left')
			this.increasePosition(-this.speed, 0)
		}
		if (this.getPosition().y > this.dy) {
			this.setDirection('up')
			this.increasePosition(0, -this.speed)
		}
		if (this.getPosition().x < this.dx) {
			this.setDirection('right')
			this.increasePosition(this.speed, 0)
		}

		let frameX = this.getPosition().x * this.world.tileSize
		let frameY = this.getPosition().y * this.world.tileSize
		let frame = Math.floor((frameX + frameY) / (this.sprite.width / 2)) % 4

		if (Math.abs(this.getPosition().x - this.dx) <= this.speed && Math.abs(this.getPosition().y - this.dy) <= this.speed) {
			this.moving = false
			this.setPosition(this.dx, this.dy)
			frame = 0

			if (this.moveCallback) {
				this.moveCallback()
			}

			let script = world.getScript(this.getPosition().x, this.getPosition().y)

			if (script && script.method === 'touch') {
				script.setSandbox({console, player})
				script.run()
			}
		}

		this.sprite.texture.frame = new PIXI.Rectangle(frame * this.sprite.width, this.directionIndex * this.sprite.height, this.sprite.width, this.sprite.height)
	}
}

Player.prototype.turn = function (a, done) {
	this.queue.push((next) => this.setDirection(a, () => {
		if (done) done()
		next()
	}))
	this.queue.start()
}

Player.prototype._move = function (dx, dy, done) {
	if (!this.moving) {
		this.setDirection(this.getDirection(dx, dy))

		let tile = this.world.getTile(this.getPosition().x + dx, this.getPosition().y + dy)

		if (tile && tile.options && tile.options.walkable) {
			this.dx += dx
			this.dy += dy
			this.moveCallback = done
			this.moving = true
		}
	}
}

Player.prototype.move = function ({x, y, queue = true} = {}, done) {
	if (queue) {
		this.queue.push((next) => this._move(x, y, () => {
			if (done) done()
			next()
		}))
		this.queue.start()
	} else {
		this._move(x, y, done)
	}
}

Player.prototype.wait = function (seconds, done) {
	this.queue.push((next) => setTimeout(() => {
		if (done) done()
		next()
	}, seconds * 1000))
	this.queue.start()
}

module.exports = Player

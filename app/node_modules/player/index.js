module.exports = function (x, y, world) {
	self = this
	this.offsetY = -22
	this.world = world
	this.queue = []

	this.sprite = Resources.getSprite('player.png')
	this.sprite.texture.frame = new PIXI.Rectangle(0, 0, this.sprite.width / 4, this.sprite.height / 4)
	this.sprite.position.x = x * this.world.tileSize
	this.sprite.position.y = y * this.world.tileSize + this.offsetY
	this.dx = x
	this.dy = y

	this.moving = false
	this.speed = 2 / this.world.tileSize
	this.direction = 'down'
	this.directionIndex = 0

	this.getPosition = function () {
		let x = this.sprite.position.x / this.world.tileSize
		let y = (this.sprite.position.y - this.offsetY) / this.world.tileSize
		return {x, y}
	}

	this.setPosition = function (x, y) {
		this.sprite.position.x = x * this.world.tileSize
		this.sprite.position.y = y * this.world.tileSize + this.offsetY
		this.dx = x
		this.dy = y
	}

	this.increasePosition = function (dx, dy) {
		this.sprite.position.x += dx * this.world.tileSize
		this.sprite.position.y += dy * this.world.tileSize
	}

	this.getFacingPosition = function () {
		let x = this.getPosition().x
		let y = this.getPosition().y

		if (this.direction === 'down')	y ++
		if (this.direction === 'left')	x --
		if (this.direction === 'right') x ++
		if (this.direction === 'up')	y --

		return {x, y}
	}

	this.getFacingTile = function () {
		return this.world.getTile(this.getFacingPosition().x, this.getFacingPosition().y)
	}

	this.getDirection = function () {
		return this.direction
	}

	this.setDirection = function (a, b) {
		if (b !== undefined) {
			if (b > 0)	this.setDirection('down')
			if (a < 0)	this.setDirection('left')
			if (a > 0)	this.setDirection('right')
			if (b < 0)	this.setDirection('up')
		} else {
			this.direction = a
			if (this.direction === 'down')	this.directionIndex = 0
			if (this.direction === 'left')	this.directionIndex = 1
			if (this.direction === 'right') this.directionIndex = 2
			if (this.direction === 'up')	this.directionIndex = 3
			this.sprite.texture.frame = new PIXI.Rectangle(0, this.directionIndex * this.sprite.height, this.sprite.width, this.sprite.height)
		}
	}

	this.update = function (time) {
		if (this.moving) {
			if (this.getPosition().y < this.dy) {
				this.setDirection('down')
				this.increasePosition(0, this.speed)
			}
			if (this.getPosition().x > this.dx) {
				this.setDirection('left')
				this.increasePosition(-this.speed, 0)
			}
			if (this.getPosition().y > this.dy) {
				this.setDirection('up')
				this.increasePosition(0, -this.speed)
			}
			if (this.getPosition().x < this.dx) {
				this.setDirection('right')
				this.increasePosition(this.speed, 0)
			}

			let frameX = this.getPosition().x * this.world.tileSize
			let frameY = this.getPosition().y * this.world.tileSize
			let frame = Math.floor((frameX + frameY) / (this.sprite.width / 2)) % 4

			if (Math.abs(this.getPosition().x - this.dx) <= this.speed && Math.abs(this.getPosition().y - this.dy) <= this.speed) {
				this.moving = false
				this.setPosition(this.dx, this.dy)
				frame = 0

				if (this.moveCallback) {
					this.moveCallback()
				}

				let tile = this.world.getTile(this.getPosition().x, this.getPosition().y)

				if (tile && tile.options && tile.options.method === 'touch') {
					this.stop()
					tile.options.execute()
				}
			}

			this.sprite.texture.frame = new PIXI.Rectangle(frame * this.sprite.width, this.directionIndex * this.sprite.height, this.sprite.width, this.sprite.height)
		}
		else {
			let f = player.queue.shift()
			if (f) f()
		}
	}

	this.queueTurn = function (a, b) {
		let fn = function () {
			self.setDirection.apply(self, [a, b])
		}
		this.queue.push(fn)
	}

	this.move = function (dx, dy, callback, queue = false) {
		if (!this.moving && (this.queue.length === 0 || queue)) {
			this.setDirection(dx, dy)

			let tile = this.world.getTile(this.getPosition().x + dx, this.getPosition().y + dy)

			if (tile && tile.options && tile.options.walkable) {
				this.dx += dx
				this.dy += dy
				this.moveCallback = callback
				this.moving = true
			}
		}
	}

	this.queueMove = function (dx, dy, callback) {
		let fn = function () {
			self.move.apply(self, [dx, dy, callback, true])
		}
		this.queue.push(fn)
	}
}
